

Week-3

1) AIM: Write a program to implement Depth Limited Search Algorithm
using Python.

    graph = {
    '5' : ['3','7'],
    '3' : ['2','4'],
    '7' : ['8'],
    '2' : [ ],
    '4' : ['8'],
    '8' : [ ]
    }
    def dls(initial,final):
      depth = 0
      max = 99
      open = [ ]
      closed = [ ]
      open.append(initial)
      while open!=[ ] :
       if depth <= max :
        m = open.pop()
        if m == final :
          closed.append(m)
          print("reached final node")
          print(closed)
          open = [ ]
        else :
            closed.append(m)
            k = neighbours(m)
            for i in k :
              open.append(i)
              depth+=1
      else :
          print("final node out of max limit")
    def neighbours(node): 
      return graph[node]
    dls('5','8')

    reached final node
    ['5', '7', '8']
    final node out of max limit

INFERENCE: DLS algorithm is used when we know the search domain, and
there exists a prior knowledge of the problem and its domain while this
is not the case for uninformed search strategy. Typically, we have
little idea of the goal nodeâ€™s depth unless one has tried to solve it
before and has found the solution.

Advantages: 1.Depth limited search is better than DFS and requires less
time and memory space. 2.DFS assures that the solution will be found if
it exists infinite time. 3.There are applications of DLS in graph theory
particularly similar to the DFS

Disadvantages:

1.  It is not complete if the solution is below the limit L (d<l),
    because it cannot find the solution .
2.  It may not find the optimal if there are more than soln.
3.  It is not time efficient since it takes O(b^L).
4.  It may cause loops if tree search used on the graph.

Applications: 1.Used in searching movies and series in applications.

2) AIM: Write a program to implement Best First Search Algorithm using
Python

    from queue import PriorityQueue
    v = 14
    graph = [[] for i in range(v)]
    def best_first_search(actual_Src, target, n):
        visited = [False] * n
        pq = PriorityQueue()
        pq.put((0, actual_Src))
        visited[actual_Src] = True
        while pq.empty() == False:
          u = pq.get()[1]
          print(u, end=" ")
          if u == target:
            break
          for v, c in graph[u]:
              if visited[v] == False:
                visited[v] = True
                pq.put((c, v))
        print()
    print("The greedy search path is : ")
    def addedge(x, y, cost):
        graph[x].append((y, cost)) 
        graph[y].append((x, cost))
    addedge(0, 1, 3)
    addedge(0, 2, 6)
    addedge(0, 3, 5)
    addedge(1, 4, 9)
    addedge(1, 5, 8)
    addedge(2, 6, 12)
    addedge(2, 7, 14)
    addedge(3, 8, 7)
    addedge(8, 9, 5)
    addedge(8, 10, 6)
    addedge(9, 11, 1)
    addedge(9, 12, 10)
    addedge(9, 13, 2)
    source = 0
    target = 9
    best_first_search(source, target, v)

    The greedy search path is : 
    0 1 3 2 8 9 

INFERENCE:

Advantages: 1.Best first search can switch between BFS and DFS by
gaining the advantages of both the algorithms. 2.This algorithm is more
efficient than BFS and DFS algorithms.

Disadvantages: 1.It can behave as an unguided depth-first search in the
worst case scenario. 2.It can get stuck in a loop as DFS. 3.This
algorithm is not optimal.

Applications: 1.used in applications as games and web crawlers.
2.Scheduling tasks for a limited number of machines so that the most
important tasks are completed first. 3.Choosing a subset of items from a
larger set so that the resulting set has the largest possible value.
4.Packing items into a container in a way that minimizes transportation
costs.

3) AIM: Write a program to implement A* Algorithm using Python

    graph = {
    'A': [('B',2),('E',3)],
    'B': [('C',1),('G',9),('A',2)],
    'C': [('B',1)],
    'D': [('E',6),('G',1)],
    'E': [('A',3),('D',6)],
    'G': [('B',9),('D',1)]
    }
    def h(n):
      H = {
     'A': 11,
     'B': 6,
     'C': 99,
     'D': 1,
     'E': 7,
     'G': 0
     }
      return H[n]
    def a_star_algorithm(start, stop):
      open_lst = set([start])
      closed_lst = set()
      adj = {}
      adj[start] = start
      cost = {}
      cost[start] = 0
      while len(open_lst) != 0:
        n = None
        for v in open_lst:
            if n == None or cost[v]+h(v) < cost[n]+h(n):
              n = v
        if n == None:
            print("NO PATH")
            return
        if n == stop:
            path = []
            while adj[n] != n:
                path.append(n)
                n = adj[n]
            path.append(start)
            print(path[::-1])
            return
      for (m,weight) in graph[n]:
          if m not in open_lst and m not in closed_lst:
            open_lst.add(m)
            adj[m] = n
            cost[m] = cost[n] + weight
          else:
            if cost[m] > cost[n] + weight:
                cost[m] = cost[n] + weight
                adj[m] = n
                if m in closed_lst:
                  closed_lst.remove(m)
                  open_lst.add(m)
      open_lst.remove(n)
      closed_lst.add(n)
      a_star_algorithm('A', 'G')
      

INFERENCE: A* Algorithm is popular because it is a technique that is
used for finding path and graph traversals. This algorithm is used by
many web-based maps and games.

Advantages: 1.A* search algorithm is the best algorithm than other
search algorithms. 2.A* search algorithm is optimal and complete.
3.algorithm can solve very complex problems.

Disadvantages: 1.It does not always produce the shortest path as it
mostly based on heuristics and approximation. 2.A* search algorithm has
some complexity issues. 3.The main drawback of A* is memory requirement
as it keeps all generated nodes in the memory, so it is not practical
for various large-scale problems.

Applications: 1.It is commonly used in web-based maps and games to find
the shortest path at the highest possible efficiency. 2.A* is used in
many artificial intelligence applications, such as search engines. 3.It
is used in other algorithms such as the Bellman-Ford algorithm to solve
the shortest path problem. 4.The A* algorithm is used in network routing
protocols, such as RIP, OSPF, and BGP, to calculate the best route
between two nodes.
